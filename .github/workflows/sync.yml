name: Auto Sync Fork with Releases

on:
  schedule:
    - cron: '0 17 * * *'  # 每天 UTC 4 点自动运行
  workflow_dispatch:      # 允许手动触发

permissions:
  contents: write
  actions: read

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    steps:
      # 1️⃣ 检出你的 fork 仓库
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          persist-credentials: false
          fetch-depth: 0

      # 2️⃣ 安装必要工具
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          # 安装 GitHub CLI
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y gh

      # 3️⃣ 配置 Git
      - name: Configure git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 4️⃣ 备份工作流文件
      - name: Backup workflow files
        run: |
          mkdir -p /tmp/backup
          # 只备份同步工作流本身
          if [ -f ".github/workflows/sync.yml" ]; then
            cp .github/workflows/sync.yml /tmp/backup/
            echo "Backed up sync workflow"
          else
            echo "No sync workflow found to backup"
          fi

      # 4.5️⃣ 删除所有可能导致问题的工作流文件
      - name: Remove problematic workflow files
        run: |
          # 删除所有可能触发构建的工作流文件
          rm -f .github/workflows/build.yml 2>/dev/null || true
          rm -f .github/workflows/android.yml 2>/dev/null || true
          rm -f .github/workflows/ci.yml 2>/dev/null || true
          rm -f .github/workflows/release.yml 2>/dev/null || true
          echo "Removed problematic workflow files"
          
          # 删除 Android 签名配置文件
          rm -f android/key.properties 2>/dev/null || true
          rm -f android/app/android_keystore.jks 2>/dev/null || true
          # 删除可能引用这些文件的 Gradle 配置
          sed -i '/android_keystore/d' android/app/build.gradle 2>/dev/null || true
          echo "Removed Android config files"

      # 5️⃣ 添加上游仓库并获取所有内容
      - name: Add upstream and fetch
        run: |
          git remote remove upstream 2>/dev/null || true
          git remote add upstream https://github.com/5VNetwork/vproxy.git
          git fetch upstream --tags --force --prune
          git fetch upstream --force --prune '+refs/heads/*:refs/remotes/upstream/*'

      # 6️⃣ 同步所有分支（保留工作流文件）
      - name: Sync branches with workflow preservation
        run: |
          # 获取默认分支名称
          default_branch=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 || echo "master")
          echo "Default branch: $default_branch"
          
          # 获取上游所有分支
          git show-ref | grep 'refs/remotes/upstream/' | while read hash ref; do
            branch_name=${ref#refs/remotes/upstream/}
            
            # 跳过 HEAD 引用
            if [ "$branch_name" = "HEAD" ]; then
              continue
            fi
            
            echo "Processing branch: $branch_name"
            
            # 创建或更新本地分支
            if git show-ref --verify --quiet refs/heads/$branch_name; then
              echo "Updating existing branch: $branch_name"
              git checkout $branch_name
              
              # 对于默认分支，使用合并而不是重置，以保留工作流文件
              if [ "$branch_name" = "$default_branch" ]; then
                echo "Merging upstream changes to default branch (preserving workflows)"
                git merge --no-commit upstream/$branch_name
                
                # 恢复工作流文件
                if [ -f "/tmp/backup/sync.yml" ]; then
                  mkdir -p .github/workflows
                  cp /tmp/backup/sync.yml .github/workflows/
                  git add .github/workflows/sync.yml
                fi
                
                # 提交合并
                if ! git diff --cached --quiet; then
                  git commit -m "Merge upstream changes and preserve workflows"
                fi
              else
                # 对于非默认分支，使用硬重置
                git reset --hard upstream/$branch_name
              fi
            else
              echo "Creating new branch: $branch_name"
              git checkout -b $branch_name upstream/$branch_name
            fi
            
            # 推送到 origin - 使用认证信息
            echo "Pushing $branch_name to origin"
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $branch_name --force
          done

      # 7️⃣ 同步所有标签（跳过包含工作流文件的标签）
      - name: Sync tags selectively
        run: |
          # 删除所有本地标签（避免冲突）
          git tag -l | xargs git tag -d 2>/dev/null || true
          # 获取上游所有标签
          git fetch upstream --tags --force
          
          # 获取所有标签
          git tag -l | while read tag; do
            # 检查标签是否包含工作流文件
            if git ls-tree -r $tag | grep -q ".github/workflows/"; then
              echo "Skipping tag $tag (contains workflow files)"
            else
              echo "Pushing tag $tag"
              git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $tag --force || echo "Failed to push tag $tag"
            fi
          done

      # 8️⃣ 获取上游发布列表和本地发布列表
      - name: Get release lists
        id: get_releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 获取上游所有发布（按创建时间排序）
          echo "Getting upstream releases..."
          upstream_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/5VNetwork/vproxy/releases?per_page=100" | \
            jq -r 'sort_by(.created_at) | .[].tag_name')
          echo "Upstream releases: $upstream_releases"
          
          # 获取本地所有发布（按创建时间排序）
          echo "Getting local releases..."
          local_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" | \
            jq -r 'sort_by(.created_at) | .[].tag_name')
          echo "Local releases: $local_releases"
          
          # 找出需要同步的新发布
          new_releases=""
          for release in $upstream_releases; do
            if ! echo "$local_releases" | grep -q "^$release$"; then
              new_releases="$new_releases $release"
            fi
          done
          
          echo "New releases to sync: $new_releases"
          
          # 设置输出变量
          echo "new_releases=$new_releases" >> $GITHUB_OUTPUT

      # 9️⃣ 只下载新发布的资源
      - name: Download new release assets
        if: steps.get_releases.outputs.new_releases != ''
        run: |
          mkdir -p releases
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          echo "New releases to process: $new_releases"
          
          # 循环处理每个新发布
          for tag_name in $new_releases; do
            echo "Processing new release: $tag_name"
            
            # 获取发布详情 - 修复：使用正确的上游仓库URL
            release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/5VNetwork/vproxy/releases/tags/$tag_name")
            
            # 检查是否有错误
            if echo "$release_info" | jq -e '.message' > /dev/null 2>&1; then
              echo "Error getting release $tag_name: $(echo "$release_info" | jq -r '.message')"
              continue
            fi
            
            release_id=$(echo "$release_info" | jq -r '.id')
            created_at=$(echo "$release_info" | jq -r '.created_at')
            echo "Release ID: $release_id, Created at: $created_at"
            
            # 为每个标签创建子目录
            mkdir -p "releases/$tag_name"
            
            # 保存发布信息到文件（包括创建时间）
            echo "$release_info" > "releases/$tag_name/release_info.json"
            
            # 下载每个资源
            assets=$(echo "$release_info" | jq -r '.assets | length')
            echo "Found $assets assets for $tag_name"
            
            if [ "$assets" -gt 0 ]; then
              for i in $(seq 0 $(($assets-1))); do
                asset_name=$(echo "$release_info" | jq -r ".assets[$i].name")
                download_url=$(echo "$release_info" | jq -r ".assets[$i].browser_download_url")
                
                echo "Downloading asset: $asset_name"
                curl -L -o "releases/$tag_name/$asset_name" "$download_url" || echo "Failed to download $asset_name"
              done
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 2
          done

      # 🔟 按照上游创建时间顺序创建新的 GitHub Releases
      - name: Create new GitHub Releases in order
        if: steps.get_releases.outputs.new_releases != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          # 首先，收集所有需要创建的发布的信息（标签名和创建时间）
          declare -A release_dates
          for tag_name in $new_releases; do
            tag_dir="releases/$tag_name"
            release_info_file="$tag_dir/release_info.json"
            if [ -f "$release_info_file" ]; then
              created_at=$(jq -r '.created_at' "$release_info_file")
              # 将日期转换为时间戳以便排序
              timestamp=$(date -d "$created_at" +%s)
              release_dates[$tag_name]=$timestamp
            else
              # 如果没有找到发布信息文件，使用当前时间戳
              release_dates[$tag_name]=$(date +%s)
            fi
          done

          # 按照时间戳排序标签名
          # 由于 Bash 关联数组不能直接排序，我们将标签名和时间戳放入数组然后排序
          # 创建一个数组，元素格式为：时间戳:标签名
          for tag_name in "${!release_dates[@]}"; do
            printf "%d:%s\n" "${release_dates[$tag_name]}" "$tag_name"
          done | sort -n | while IFS=: read -r timestamp tag_name; do
            # 现在按照排序后的顺序处理每个标签
            tag_dir="releases/$tag_name"
            
            if [ -d "$tag_dir" ]; then
              echo "Creating release: $tag_name"
              
              # 读取发布信息
              release_info_file="$tag_dir/release_info.json"
              if [ -f "$release_info_file" ]; then
                release_name=$(jq -r '.name' "$release_info_file")
                release_notes=$(jq -r '.body' "$release_info_file")
                prerelease=$(jq -r '.prerelease' "$release_info_file")
                draft=$(jq -r '.draft' "$release_info_file")
                created_at=$(jq -r '.created_at' "$release_info_file")
                
                # 设置发布参数
                prerelease_flag=""
                draft_flag=""
                if [ "$prerelease" = "true" ]; then
                  prerelease_flag="--prerelease"
                fi
                if [ "$draft" = "true" ]; then
                  draft_flag="--draft"
                fi
                
                # 收集所有资产文件（排除 release_info.json）
                asset_files=()
                for file in "$tag_dir"/*; do
                  if [[ "$file" != *"release_info.json" ]]; then
                    asset_files+=("$file")
                  fi
                done
                
                # 检查是否有资产文件
                if [ ${#asset_files[@]} -eq 0 ]; then
                  echo "No asset files found for $tag_name, skipping release creation"
                  continue
                fi
                
                echo "Found ${#asset_files[@]} asset files for $tag_name"
                
                # 创建发布 - 关键修改：添加 --repo 参数
                if [ -n "$release_name" ] && [ "$release_name" != "null" ]; then
                  # 先创建发布，然后单独上传每个文件
                  gh release create --repo ${{ github.repository }} "$tag_name" \
                    --title "$release_name" \
                    --notes "$release_notes" \
                    $prerelease_flag \
                    $draft_flag \
                    --target master || echo "Release $tag_name may already exist"
                else
                  gh release create --repo ${{ github.repository }} "$tag_name" \
                    --notes "$release_notes" \
                    $prerelease_flag \
                    $draft_flag \
                    --target master || echo "Release $tag_name may already exist"
                fi
                
                # 上传每个资产文件 - 关键修改：添加 --repo 参数
                for asset_file in "${asset_files[@]}"; do
                  echo "Uploading asset: $asset_file"
                  gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                done
                
                echo "Created release: $tag_name with ${#asset_files[@]} assets"
              else
                echo "No release info found for $tag_name"
              fi
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 5
          done

      # 清理下载的资源
      - name: Clean up downloaded assets
        run: |
          rm -rf releases
          echo "Cleaned up downloaded assets"

      # 发送完成通知
      - name: Notify on completion
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          if [ -n "$new_releases" ]; then
            echo "Sync completed at $(date)"
            echo "New releases synced: $new_releases"
          else
            echo "Sync completed at $(date)"
            echo "No new releases to sync"
          fi
          echo "Repository: https://github.com/${{ github.repository }}"
